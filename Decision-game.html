<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Decision Game â€“ People Of The World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #1e293b;
      --accent: #38bdf8;
      --accent-soft: #0ea5e9;
      --danger: #f97373;
      --success: #4ade80;
      --text: #e5e7eb;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 16px;
      box-sizing: border-box;
    }

    .game-container {
      width: 100%;
      max-width: 900px;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 16px;
      padding: 12px 12px 20px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
      box-sizing: border-box;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 1.6rem;
      text-align: center;
    }

    .subtitle {
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.8;
      margin-bottom: 12px;
    }

    .top-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-bottom: 8px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      background: var(--panel);
      color: var(--text);
      transition: background 0.15s, transform 0.08s, box-shadow 0.08s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
      white-space: nowrap;
    }

    button:hover {
      background: #0b5f82;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.65);
    }

    #startStopButton {
      background: var(--accent);
      color: #020617;
      font-weight: 600;
    }

    #startStopButton.running {
      background: #ef4444;
      color: #f9fafb;
    }

    #modeButton {
      background: #111827;
    }

    #leaderboardModeButton {
      background: #0f766e;
    }

    .info-panel {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      font-size: 0.78rem;
      background: #020617;
      padding: 6px;
      border-radius: 10px;
      margin-bottom: 8px;
    }

    .info-cell {
      opacity: 0.9;
    }

    .info-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      opacity: 0.7;
    }

    .info-value {
      font-weight: 600;
    }

    .flash-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin: 8px 0 10px;
      flex-wrap: nowrap;
    }

    .word-box, .relation-box, .image-box {
      background: #020617;
      border-radius: 14px;
      padding: 10px;
      text-align: center;
      min-height: 80px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      flex: 1 1 0;
    }

    .word-box {
      font-size: 1.3rem;
      font-weight: 700;
      letter-spacing: 0.06em;
    }

    .relation-box span {
      font-size: 1.2rem;
      font-weight: 700;
    }

    .relation-is {
      color: var(--success);
    }

    .relation-not {
      color: #fecaca;
    }

    .image-box img {
      max-width: 100%;
      max-height: 110px;
      object-fit: contain;
      display: block;
    }

    .answer-buttons {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }

    .answer-buttons button {
      flex: 1;
      padding: 12px 8px;
      font-size: 1.1rem;
      font-weight: 700;
    }

    #falseButton {
      background: #111827;
      border: 2px solid #ef4444;
      color: #fecaca;
    }

    #trueButton {
      background: #111827;
      border: 2px solid #22c55e;
      color: #bbf7d0;
    }

    .leaderboard-panel {
      margin-top: 8px;
      background: #020617;
      border-radius: 12px;
      padding: 6px;
    }

    .leaderboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 0.85rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    th, td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      white-space: nowrap;
    }

    th {
      font-weight: 600;
      opacity: 0.85;
    }

    tr:nth-child(even) td {
      background: rgba(15, 23, 42, 0.6);
    }

    .rank-cell {
      width: 30px;
    }

    .initials-cell {
      width: 60px;
    }

    .name-input-row {
      margin-top: 6px;
      display: flex;
      gap: 6px;
      align-items: center;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    .name-input-row input {
      border-radius: 999px;
      border: 1px solid #4b5563;
      padding: 5px 10px;
      background: #020617;
      color: var(--text);
      outline: none;
      width: 90px;
    }

    .tiny-note {
      font-size: 0.7rem;
      opacity: 0.7;
    }

    /* Instructions modal */
    #instructionsModal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.88);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }

    #instructionsContent {
      background: #020617;
      border-radius: 16px;
      padding: 18px 16px;
      max-width: 500px;
      margin: 0 12px;
      font-size: 0.9rem;
      box-shadow: 0 18px 40px rgba(0,0,0,0.9);
    }

    #instructionsContent h2 {
      margin-top: 0;
      margin-bottom: 6px;
      font-size: 1.1rem;
    }

    #instructionsContent ul {
      margin: 4px 0 8px 20px;
      padding: 0;
    }

    #instructionsContent li {
      margin-bottom: 4px;
    }

    #countdownOverlay {
      position: absolute;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 20;
    }

    #countdownOverlay span {
      font-size: 4rem;
      font-weight: 800;
      text-shadow: 0 0 20px rgba(56,189,248,0.8);
    }

    .game-shell {
      position: relative;
    }

    @media (max-width: 600px) {
      .game-container {
        padding: 10px;
      }
      .info-panel {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .flash-row {
        flex-direction: row;
        align-items: stretch;
      }
      .word-box, .relation-box, .image-box {
        min-height: 70px;
      }
      .answer-buttons button {
        padding: 10px 4px;
        font-size: 1rem;
      }
      h1 {
        font-size: 1.3rem;
      }
      .subtitle {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>Decision Game</h1>
    <div class="subtitle">Test and improve your decision making speed and accuracy</div>

    <div class="game-shell">
      <div id="countdownOverlay"><span id="countdownNumber"></span></div>

      <div class="top-controls">
        <button id="modeButton">Mode: Practice</button>
        <button id="startStopButton">Start</button>
        <button id="leaderboardModeButton">Leaderboard: Short</button>
      </div>

      <div class="info-panel">
        <div class="info-cell">
          <div class="info-label">Mode</div>
          <div class="info-value" id="infoMode">Practice</div>
        </div>
        <div class="info-cell">
          <div class="info-label">Question</div>
          <div class="info-value" id="infoQuestion">0</div>
        </div>
        <div class="info-cell">
          <div class="info-label">Correct / Incorrect</div>
          <div class="info-value" id="infoScore">0 / 0</div>
        </div>
        <div class="info-cell">
          <div class="info-label">Run Time</div>
          <div class="info-value" id="infoRunTime">0.00s</div>
        </div>
        <div class="info-cell">
          <div class="info-label">Avg Time</div>
          <div class="info-value" id="infoAvgTime">0.00s</div>
        </div>
        <div class="info-cell">
          <div class="info-label">Infinite Limit</div>
          <div class="info-value" id="infoInfiniteLimit">â€“</div>
        </div>
      </div>

      <!-- ðŸ” ORDER CHANGED: picture (left), relation (middle), word (right) -->
      <div class="flash-row">
        <div class="image-box">
          <img id="pictureBox" src="" alt="object" />
        </div>
        <div class="relation-box" id="relationBox">
          <span class="relation-is">IS</span>
        </div>
        <div class="word-box" id="wordBox">WORD</div>
      </div>

      <div class="answer-buttons">
        <button id="falseButton">FALSE</button>
        <button id="trueButton">TRUE</button>
      </div>
    </div>

    <div class="leaderboard-panel">
      <div class="leaderboard-header">
        <span id="leaderboardTitle">Leaderboard â€“ Short</span>
        <button id="refreshLeaderboardButton">Refresh</button>
      </div>
      <table>
        <thead>
          <tr>
            <th class="rank-cell">#</th>
            <th class="initials-cell">Init</th>
            <th>Correct</th>
            <th>Questions</th>
            <th>Total</th>
            <th>Avg</th>
          </tr>
        </thead>
        <tbody id="leaderboardBody">
        </tbody>
      </table>

      <div class="name-input-row">
        <div>
          Initials:
          <input id="initialsInput" maxlength="3" placeholder="ABC" />
        </div>
        <span class="tiny-note">Only full short/long runs and infinite runs that end by mistake or timeout are saved.</span>
      </div>
    </div>
  </div>

  <!-- Instructions Modal -->
  <div id="instructionsModal">
    <div id="instructionsContent">
      <h2>How to Play</h2>
      <ul>
        <li>A picture appears on the left and a word on the right.</li>
        <li>The middle box shows <strong>IS</strong> or <strong style="color:#fecaca;">IS NOT</strong>.</li>
        <li>
          When it says <strong>IS</strong>:
          press <strong>TRUE</strong> if the word and picture match, otherwise press <strong>FALSE</strong>.
        </li>
        <li>
          When it says <strong>IS NOT</strong>:
          the logic is reversed â€“ press <strong>TRUE</strong> if they do <em>not</em> match.
        </li>
        <li><strong>Practice:</strong> play freely, no leaderboard.</li>
        <li><strong>Short:</strong> 10 questions. <strong>Long:</strong> 20 questions.</li>
        <li>
          <strong>Infinite:</strong> you get <em>one mistake only</em>. Each answer is timed.
          Time starts at 1.0s and gets shorter by 0.1s every 50 correct answers, down to 0.3s.
        </li>
        <li>On computer you can also use the arrow keys: <strong>Left = FALSE</strong>, <strong>Right = TRUE</strong>.</li>
      </ul>
      <button id="closeInstructionsButton">Got it</button>
    </div>
  </div>

  <script>
    // -----------------------------
    // Data: images & words
    // -----------------------------

    const ITEMS = [
      { key: 'ball',      label: 'BALL',      url: 'https://static.wixstatic.com/media/eaef6d_7f2b9555f08e4407bcf27857bf332d3c~mv2.png' },
      { key: 'umbrella',  label: 'UMBRELLA',  url: 'https://static.wixstatic.com/media/eaef6d_a783bbb23e2f4960a84c5946322bd1d1~mv2.png' },
      { key: 'pig',       label: 'PIG',       url: 'https://static.wixstatic.com/media/eaef6d_12d8e64c3bbb45749e7d2328b1ea3329~mv2.png' },
      { key: 'butterfly', label: 'BUTTERFLY', url: 'https://static.wixstatic.com/media/eaef6d_87217c52f3b44756834c0cc47ddb62fc~mv2.png' },
      { key: 'airplane',  label: 'AIRPLANE',  url: 'https://static.wixstatic.com/media/eaef6d_fd2e5d6a21154331aad70d6079dce246~mv2.png' },
      { key: 'car',       label: 'CAR',       url: 'https://static.wixstatic.com/media/eaef6d_ce7258f9c42342c49453582be5a69c88~mv2.png' },
      { key: 'mouse',     label: 'MOUSE',     url: 'https://static.wixstatic.com/media/eaef6d_cb46105a23d049808c595598fe7d883f~mv2.png' },
      { key: 'hat',       label: 'HAT',       url: 'https://static.wixstatic.com/media/eaef6d_bb22e0b78d134c88bb6c67d4941ece27~mv2.png' },
      { key: 'house',     label: 'HOUSE',     url: 'https://static.wixstatic.com/media/eaef6d_6ece4136d1ec4dc8bf3f51c8e244766b~mv2.png' },
      { key: 'cow',       label: 'COW',       url: 'https://static.wixstatic.com/media/eaef6d_df0c98fc5b28458db695aa5cb3d414a8~mv2.png' },
      { key: 'bus',       label: 'BUS',       url: 'https://static.wixstatic.com/media/eaef6d_64f8949a66c14145948d1cb0db7e7224~mv2.png' },
      { key: 'tree',      label: 'TREE',      url: 'https://static.wixstatic.com/media/eaef6d_0fd2bc64878e41a299cc22c3f0a35abf~mv2.png' },
      { key: 'flower',    label: 'FLOWER',    url: 'https://static.wixstatic.com/media/eaef6d_8cf53ea56de040f2b2ceecfe2a2619b4~mv2.png' },
      { key: 'bee',       label: 'BEE',       url: 'https://static.wixstatic.com/media/eaef6d_8f18d62b58914a7085530ea3d3183901~mv2.png' },
      { key: 'cup',       label: 'CUP',       url: 'https://static.wixstatic.com/media/eaef6d_633ee54b4fd9427bb9ef5a3d2e027fe3~mv2.png' },
      { key: 'ballerina', label: 'BALLERINA', url: 'https://static.wixstatic.com/media/eaef6d_2a8b7bce57d24700b5bd133da2da1dd1~mv2.png' },
      { key: 'bird',      label: 'BIRD',      url: 'https://static.wixstatic.com/media/eaef6d_653bf4fd82f94aff94796803666e80de~mv2.png' },
      { key: 'chair',     label: 'CHAIR',     url: 'https://static.wixstatic.com/media/eaef6d_3b4a0f88dd6d4ba485ed22d103eabf2a~mv2.png' },
      { key: 'book',      label: 'BOOK',      url: 'https://static.wixstatic.com/media/eaef6d_f0408751e9a640d88066b46722a8ea91~mv2.png' },
      { key: 'cherries',  label: 'CHERRY',    url: 'https://static.wixstatic.com/media/eaef6d_97c92754a41d489eb0bb984377487207~mv2.png' }
    ];

    const ITEM_KEYS = ITEMS.map(i => i.key);

    // -----------------------------
    // DOM elements
    // -----------------------------

    const modeButton = document.getElementById('modeButton');
    const startStopButton = document.getElementById('startStopButton');
    const leaderboardModeButton = document.getElementById('leaderboardModeButton');
    const refreshLeaderboardButton = document.getElementById('refreshLeaderboardButton');

    const infoModeEl = document.getElementById('infoMode');
    const infoQuestionEl = document.getElementById('infoQuestion');
    const infoScoreEl = document.getElementById('infoScore');
    const infoRunTimeEl = document.getElementById('infoRunTime');
    const infoAvgTimeEl = document.getElementById('infoAvgTime');
    const infoInfiniteLimitEl = document.getElementById('infoInfiniteLimit');

    const wordBox = document.getElementById('wordBox');
    const relationBox = document.getElementById('relationBox');
    const pictureBox = document.getElementById('pictureBox');

    const trueButton = document.getElementById('trueButton');
    const falseButton = document.getElementById('falseButton');

    const leaderboardTitle = document.getElementById('leaderboardTitle');
    const leaderboardBody = document.getElementById('leaderboardBody');
    const initialsInput = document.getElementById('initialsInput');

    const instructionsModal = document.getElementById('instructionsModal');
    const closeInstructionsButton = document.getElementById('closeInstructionsButton');

    const countdownOverlay = document.getElementById('countdownOverlay');
    const countdownNumber = document.getElementById('countdownNumber');

    // -----------------------------
    // Audio (no external files)
    // -----------------------------
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;

    function ensureAudioCtx() {
      if (!AudioCtx) return null;
      if (!audioCtx) {
        audioCtx = new AudioCtx();
      }
      return audioCtx;
    }

    function beep(freq = 440, duration = 0.12, type = 'sine') {
      const ctx = ensureAudioCtx();
      if (!ctx) return;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.18, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.start(now);
      osc.stop(now + duration);
    }

    function playStartBell() {
      beep(700, 0.18, 'triangle');
    }

    function playCorrect() {
      beep(1100, 0.09, 'square');
    }

    function playWrong() {
      beep(220, 0.16, 'sawtooth');
    }

    function playEndChime() {
      beep(550, 0.12, 'triangle');
      setTimeout(() => beep(880, 0.12, 'triangle'), 130);
    }

    // -----------------------------
    // Game state
    // -----------------------------

    const modes = ['practice', 'short', 'long', 'infinite'];
    let currentModeIndex = 0;
    let currentMode = modes[currentModeIndex];

    const leaderboardModes = ['short', 'long', 'infinite'];
    let currentLeaderboardIndex = 0;

    let runActive = false;
    let questionNumber = 0;
    let correctCount = 0;
    let incorrectCount = 0;

    let runStartTime = null;
    let lastQuestionTime = null;
    let perQuestionDurations = [];

    let totalQuestionsTarget = null; // 10 or 20 for short/long, null otherwise
    let runTimerInterval = null;

    let currentCorrectAnswerIsTrue = true;
    let lastWordKey = null;
    let lastPictureKey = null;
    let lastRelation = null;
    let relationStreak = 0;

    // For short/long: use each picture once
    let remainingPicturesForRun = [];

    // Infinite mode state
    let infiniteActive = false;
    let infiniteQuestionsAnswered = 0;
    let infiniteTimeLimitMs = 1000;
    const INFINITE_START_LIMIT_MS = 1000;
    const INFINITE_MIN_LIMIT_MS = 300;
    let questionTimeoutId = null;

    // Whether current run should be saved (completed / failed naturally)
    let runEndReason = null; // 'completed', 'error', 'timeout', 'aborted'

    const API_BASE = 'https://www.peopleoftheworld.net/_functions/decisionGame';

    // -----------------------------
    // Utility
    // -----------------------------

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function pickRandomItem(excludeKey = null) {
      const candidates = excludeKey ? ITEMS.filter(it => it.key !== excludeKey) : ITEMS;
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

    function updateInfoPanel() {
      infoModeEl.textContent = currentMode[0].toUpperCase() + currentMode.slice(1);
      infoQuestionEl.textContent = questionNumber;
      infoScoreEl.textContent = `${correctCount} / ${incorrectCount}`;

      if (runActive && runStartTime != null) {
        const now = performance.now();
        const totalMs = now - runStartTime;
        infoRunTimeEl.textContent = (totalMs / 1000).toFixed(2) + 's';

        const answered = perQuestionDurations.length;
        if (answered > 0) {
          const sum = perQuestionDurations.reduce((a, b) => a + b, 0);
          infoAvgTimeEl.textContent = ((sum / answered) / 1000).toFixed(2) + 's';
        } else {
          infoAvgTimeEl.textContent = '0.00s';
        }
      } else {
        infoRunTimeEl.textContent = '0.00s';
        infoAvgTimeEl.textContent = '0.00s';
      }

      if (currentMode === 'infinite') {
        infoInfiniteLimitEl.textContent = (infiniteTimeLimitMs / 1000).toFixed(2) + 's';
      } else {
        infoInfiniteLimitEl.textContent = 'â€“';
      }
    }

    function startRunTimer() {
      if (runTimerInterval) clearInterval(runTimerInterval);
      runTimerInterval = setInterval(updateInfoPanel, 100);
    }

    function stopRunTimer() {
      if (runTimerInterval) {
        clearInterval(runTimerInterval);
        runTimerInterval = null;
      }
      updateInfoPanel();
    }

    function scheduleInfiniteTimeout() {
      if (!infiniteActive) return;
      if (questionTimeoutId) {
        clearTimeout(questionTimeoutId);
        questionTimeoutId = null;
      }
      questionTimeoutId = setTimeout(() => {
        handleInfiniteFailure('timeout');
      }, infiniteTimeLimitMs);
    }

    function updateInfiniteTimeLimit() {
      const blocksOf50 = Math.floor(infiniteQuestionsAnswered / 50);
      const reduction = blocksOf50 * 100;
      infiniteTimeLimitMs = Math.max(INFINITE_MIN_LIMIT_MS, INFINITE_START_LIMIT_MS - reduction);
    }

    function resetRunState() {
      runActive = false;
      questionNumber = 0;
      correctCount = 0;
      incorrectCount = 0;
      runStartTime = null;
      lastQuestionTime = null;
      perQuestionDurations = [];
      totalQuestionsTarget = null;
      runEndReason = null;

      if (runTimerInterval) {
        clearInterval(runTimerInterval);
        runTimerInterval = null;
      }

      if (questionTimeoutId) {
        clearTimeout(questionTimeoutId);
        questionTimeoutId = null;
      }

      infiniteActive = false;
      infiniteQuestionsAnswered = 0;
      infiniteTimeLimitMs = INFINITE_START_LIMIT_MS;

      lastWordKey = null;
      lastPictureKey = null;
      lastRelation = null;
      relationStreak = 0;

      remainingPicturesForRun = [];
      updateInfoPanel();
    }

    function setModeLabel() {
      modeButton.textContent = 'Mode: ' + currentMode[0].toUpperCase() + currentMode.slice(1);
      infoModeEl.textContent = currentMode[0].toUpperCase() + currentMode.slice(1);
    }

    function setLeaderboardModeLabel() {
      const mode = leaderboardModes[currentLeaderboardIndex];
      const label = mode[0].toUpperCase() + mode.slice(1);
      leaderboardModeButton.textContent = 'Leaderboard: ' + label;
      leaderboardTitle.textContent = 'Leaderboard â€“ ' + label;
    }

    // -----------------------------
    // Question generation
    // -----------------------------

    function generateQuestion() {
      // Choose word
      let wordItem;
      if (currentMode === 'short' || currentMode === 'long') {
        if (remainingPicturesForRun.length === 0) {
          remainingPicturesForRun = shuffleArray(ITEM_KEYS);
        }
        const picKey = remainingPicturesForRun.shift();
        const picItem = ITEMS.find(i => i.key === picKey);

        // Decide match vs mismatch
        const shouldMatch = Math.random() < 0.5;
        if (shouldMatch) {
          wordItem = picItem;
        } else {
          // pick any other word
          let otherItem = pickRandomItem(picKey);
          wordItem = otherItem;
        }

        // set picture
        pictureBox.src = picItem.url;
        pictureBox.alt = picItem.label;
        lastPictureKey = picItem.key;
      } else {
        // practice / infinite: random, but avoid immediate repetition of word & picture
        let picItem;
        do {
          picItem = ITEMS[Math.floor(Math.random() * ITEMS.length)];
        } while (picItem.key === lastPictureKey);

        const shouldMatch = Math.random() < 0.5;
        if (shouldMatch) {
          wordItem = picItem;
        } else {
          let otherItem;
          do {
            otherItem = pickRandomItem(picItem.key);
          } while (otherItem.key === lastWordKey);
          wordItem = otherItem;
        }

        pictureBox.src = picItem.url;
        pictureBox.alt = picItem.label;
        lastPictureKey = picItem.key;
      }

      lastWordKey = wordItem.key;
      wordBox.textContent = wordItem.label;

      // Determine actual match of word vs picture
      const pictureKey = lastPictureKey;
      const matches = (wordItem.key === pictureKey);

      // Choose relation IS / IS NOT with rule: no more than 2 in a row
      let relation;
      if (!lastRelation) {
        relation = Math.random() < 0.5 ? 'is' : 'is not';
        relationStreak = 1;
      } else {
        const canRepeat = relationStreak < 2;
        if (canRepeat && Math.random() < 0.5) {
          relation = lastRelation;
          relationStreak += 1;
        } else {
          relation = lastRelation === 'is' ? 'is not' : 'is';
          relationStreak = 1;
        }
      }
      lastRelation = relation;

      relationBox.innerHTML = '';
      const span = document.createElement('span');
      if (relation === 'is') {
        span.textContent = 'IS';
        span.className = 'relation-is';
      } else {
        span.textContent = 'IS NOT';
        span.className = 'relation-not';
      }
      relationBox.appendChild(span);

      // Determine correct answer (true/false)
      let baseTruth = matches;
      if (relation === 'is not') {
        baseTruth = !baseTruth;
      }
      currentCorrectAnswerIsTrue = baseTruth;

      // Per-question timing start
      lastQuestionTime = performance.now();

      // Infinite: update time limit and schedule timeout
      if (currentMode === 'infinite' && infiniteActive) {
        updateInfiniteTimeLimit();
        updateInfoPanel();
        scheduleInfiniteTimeout();
      }
    }

    // -----------------------------
    // Run control
    // -----------------------------

    function startCountdownAndRun() {
      countdownOverlay.style.display = 'flex';
      let count = 3;
      countdownNumber.textContent = count;
      beep(500, 0.12, 'triangle');

      const interval = setInterval(() => {
        count -= 1;
        if (count > 0) {
          countdownNumber.textContent = count;
          beep(500, 0.12, 'triangle');
        } else {
          clearInterval(interval);
          countdownOverlay.style.display = 'none';
          playStartBell();
          actuallyStartRun();
        }
      }, 800);
    }

    function actuallyStartRun() {
      resetRunState();
      runActive = true;
      startStopButton.classList.add('running');
      startStopButton.textContent = 'Stop';
      runStartTime = performance.now();
      startRunTimer();

      if (currentMode === 'short') {
        totalQuestionsTarget = 10;
      } else if (currentMode === 'long') {
        totalQuestionsTarget = 20;
      } else {
        totalQuestionsTarget = null;
      }

      if (currentMode === 'infinite') {
        infiniteActive = true;
        infiniteQuestionsAnswered = 0;
        infiniteTimeLimitMs = INFINITE_START_LIMIT_MS;
      }

      if (currentMode === 'short' || currentMode === 'long') {
        remainingPicturesForRun = shuffleArray(ITEM_KEYS);
      }

      questionNumber = 0;
      generateQuestion();
      questionNumber = 1;
      updateInfoPanel();
    }

    function endRun(reason) {
      if (!runActive) return;
      runActive = false;
      runEndReason = reason || 'completed';
      stopRunTimer();
      startStopButton.classList.remove('running');
      startStopButton.textContent = 'Start';

      if (questionTimeoutId) {
        clearTimeout(questionTimeoutId);
        questionTimeoutId = null;
      }

      const now = performance.now();
      const totalMs = runStartTime ? (now - runStartTime) : 0;

      const answered = perQuestionDurations.length;
      let avgMs = 0;
      if (answered > 0) {
        const sum = perQuestionDurations.reduce((a, b) => a + b, 0);
        avgMs = sum / answered;
      }

      updateInfoPanel();
      playEndChime();

      const validModesForSave = ['short', 'long', 'infinite'];

      if (
        validModesForSave.includes(currentMode) &&
        runEndReason !== 'aborted'
      ) {
        let totalQuestions;
        if (currentMode === 'infinite') {
          totalQuestions = infiniteQuestionsAnswered;
        } else {
          totalQuestions = totalQuestionsTarget || questionNumber;
        }

        if (totalQuestions > 0) {
          const initialsRaw = (initialsInput.value || '').trim().toUpperCase();
          const initials = initialsRaw || '???';

          const payload = {
            initials,
            mode: currentMode,
            correct: correctCount,
            totalQuestions: totalQuestions,
            totalTimeMs: totalMs,
            avgTimeMs: avgMs
          };
          saveScoreToServer(payload).then(() => {
            const viewMode = leaderboardModes[currentLeaderboardIndex];
            if (viewMode === currentMode) {
              updateLeaderboardUI(viewMode);
            }
          });
        }
      }
    }

    function handleInfiniteFailure(reason) {
      infiniteActive = false;
      playWrong();
      endRun(reason);
    }

    // -----------------------------
    // Answer handling
    // -----------------------------

    function handleAnswer(userChoseTrue) {
      if (!runActive) return;

      const now = performance.now();

      if (questionTimeoutId) {
        clearTimeout(questionTimeoutId);
        questionTimeoutId = null;
      }

      let questionDuration = 0;
      if (lastQuestionTime != null) {
        questionDuration = now - lastQuestionTime;
        perQuestionDurations.push(questionDuration);
      }

      const isCorrect = (userChoseTrue === currentCorrectAnswerIsTrue);

      if (isCorrect) {
        correctCount += 1;
        playCorrect();
      } else {
        incorrectCount += 1;
        playWrong();
      }

      if (currentMode === 'infinite') {
        if (!isCorrect) {
          handleInfiniteFailure('error');
          return;
        } else {
          infiniteQuestionsAnswered += 1;
          questionNumber += 1;
          updateInfoPanel();
          generateQuestion();
          return;
        }
      }

      // Practice / short / long
      questionNumber += 1;
      updateInfoPanel();

      if ((currentMode === 'short' || currentMode === 'long') && totalQuestionsTarget != null) {
        if (questionNumber > totalQuestionsTarget) {
          endRun('completed');
          return;
        }
      }

      generateQuestion();
    }

    // -----------------------------
    // Backend interactions
    // -----------------------------

    async function saveScoreToServer(payload) {
      try {
        await fetch(API_BASE + '/saveScore', {
          method: 'POST',
          headers: {
            'Content-Type': 'text/plain'
          },
          body: JSON.stringify(payload)
        });
      } catch (err) {
        console.error('Error saving score:', err);
      }
    }

    async function fetchLeaderboardFromServer(mode) {
      try {
        const res = await fetch(API_BASE + '/leaderboard?mode=' + encodeURIComponent(mode));
        if (!res.ok) {
          console.error('Leaderboard fetch failed with status', res.status);
          return [];
        }
        const data = await res.json();
        return data.results || [];
      } catch (err) {
        console.error('Error fetching leaderboard:', err);
        return [];
      }
    }

    async function updateLeaderboardUI(mode) {
      const rows = await fetchLeaderboardFromServer(mode);
      leaderboardBody.innerHTML = '';
      rows.forEach(entry => {
        const tr = document.createElement('tr');

        const rankTd = document.createElement('td');
        rankTd.className = 'rank-cell';
        rankTd.textContent = entry.rank;

        const initTd = document.createElement('td');
        initTd.className = 'initials-cell';
        initTd.textContent = entry.initials;

        const correctTd = document.createElement('td');
        correctTd.textContent = entry.correct;

        const totalTd = document.createElement('td');
        totalTd.textContent = entry.totalQuestions;

        const totalTimeTd = document.createElement('td');
        totalTimeTd.textContent = (entry.totalTimeMs / 1000).toFixed(2) + 's';

        const avgTimeTd = document.createElement('td');
        avgTimeTd.textContent = (entry.avgTimeMs / 1000).toFixed(2) + 's';

        tr.appendChild(rankTd);
        tr.appendChild(initTd);
        tr.appendChild(correctTd);
        tr.appendChild(totalTd);
        tr.appendChild(totalTimeTd);
        tr.appendChild(avgTimeTd);

        leaderboardBody.appendChild(tr);
      });
    }

    // -----------------------------
    // Event wiring
    // -----------------------------

    modeButton.addEventListener('click', () => {
      if (runActive) return;
      currentModeIndex = (currentModeIndex + 1) % modes.length;
      currentMode = modes[currentModeIndex];
      setModeLabel();
      resetRunState();
    });

    startStopButton.addEventListener('click', () => {
      if (!runActive) {
        startCountdownAndRun();
      } else {
        endRun('aborted');
      }
    });

    trueButton.addEventListener('click', () => {
      handleAnswer(true);
    });

    falseButton.addEventListener('click', () => {
      handleAnswer(false);
    });

    document.addEventListener('keydown', (e) => {
      if (!runActive) return;
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        handleAnswer(false);
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        handleAnswer(true);
      }
    });

    leaderboardModeButton.addEventListener('click', () => {
      currentLeaderboardIndex = (currentLeaderboardIndex + 1) % leaderboardModes.length;
      setLeaderboardModeLabel();
      const mode = leaderboardModes[currentLeaderboardIndex];
      updateLeaderboardUI(mode);
    });

    refreshLeaderboardButton.addEventListener('click', () => {
      const mode = leaderboardModes[currentLeaderboardIndex];
      updateLeaderboardUI(mode);
    });

    closeInstructionsButton.addEventListener('click', () => {
      instructionsModal.style.display = 'none';
    });

    // -----------------------------
    // Init
    // -----------------------------

    (function initPlaceholder() {
      const item = ITEMS[Math.floor(Math.random() * ITEMS.length)];
      pictureBox.src = item.url;
      pictureBox.alt = item.label;
      wordBox.textContent = item.label;
    })();

    setModeLabel();
    setLeaderboardModeLabel();
    updateInfoPanel();
    updateLeaderboardUI('short');
  </script>
</body>
</html>
